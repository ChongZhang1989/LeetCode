class Solution {
    #define MAX 100000000
	struct node {
		int step;
		int v;
		node(int _step, int _v)
		{
			step = _step;
			v = _v;
		}
	};
public:
    int ladderLength(string start, string end, unordered_set<string> &dict) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        unordered_map<string, int>rec;
        int n = 1;
        rec[start] = 0;
        for (unordered_set<string>::iterator it = dict.begin(); it != dict.end(); ++it) {
        	if (rec.count(*it) )
        		continue;
        	rec[(*it)] = n++;
        }
        rec[end] = n++;
        vector<vector<int> >g (n, vector<int>() );
        for (unordered_map<string, int>::iterator it = rec.begin(); it != rec.end(); ++it) {
        	string s = (*it).first;
        	int k = (*it).second;
        	for (int i = 0; i < s.size(); ++i) {
        		string t = s;
        		for (int j = 0; j < 26; ++j) {
        			if (j + 'a' == s[i])
        				continue;
        			t[i] = j + 'a';
        			if (!rec.count(t) )
        				continue;
        			g[k].push_back(rec[t]);
        		}
        	}
        }
        
        queue<node>q;
        q.push(node(1, 0) );
        vector<int>visit (n, 0);
        while (!q.empty() ) {
        	node t = q.front();
        	q.pop();
        	int m = g[t.v].size();
        	for (int i = 0; i < m; ++i) {
        		if (g[t.v][i] == n - 1) {
        			return t.step + 1;
        		}
        		if (visit[g[t.v][i]])
        			continue;
        		q.push(node(t.step + 1, g[t.v][i]) );
        		visit[g[t.v][i]] = 1;
        	}
        }
        return 0;
    }
};